<?xml version="1.0"?>
<bindings xmlns="http://www.mozilla.org/xbl" xmlns:html="http://www.w3.org/1999/xhtml">

<binding id="RepetitionElement">
 <implementation>
  <property name="REPETITION_NONE">
   <getter>return 0</getter>
  </property>
  <property name="REPETITION_TEMPLATE">
   <getter>return 1</getter>
  </property>
  <property name="REPETITION_BLOCK">
   <getter>return 2</getter>
  </property>
  
  <property name="repetitionType">
   <getter>
    if (this.hasAttribute("repeat")) {
      var repeat = this.getAttribute("repeat");
      if (repeat == "template") {
        return this.REPETITION_TEMPLATE;
      }
      var INTEGER = /^\-?\d+$/;
      if (INTEGER.test(repeat)) {
        return this.REPETITION_BLOCK;
      }
    }
    return this.REPETITION_NONE;
   </getter>
   <setter>
    switch (val) {
      case this.REPETITION_NONE:
        this.removeAttribute("repeat");
        break;
      case this.REPETITION_TEMPLATE:
        this.setAttribute("repeat", "template");
        break;
      case this.REPETITION_BLOCK:
        this.setAttribute("repeat", this.repetitionIndex);
        break;
      default:
        throw new Error("NOT_SUPPORTED_ERR");
    }
    return val;
   </setter>  
  </property>
  
  <field name="repetitionIndex">0</field>
  
  <property name="repetitionTemplate">
   <getter>return null</getter>
  </property>
  
  <property name="repetitionBlocks">
   <getter>return null</getter>
  </property>
  
  <property name="repeatStart"/>
  
  <property name="repeatMin"/>
  
  <property name="repeatMax"/>
  
  <method name="addRepetitionBlock">
   <parameter name="refNode"/>
   <body><![CDATA[
    if (arguments.length < 1) {
      throw new SyntaxError("not enough arguments");
    }
    return null;
   ]]></body>
  </method>
  
  <method name="addRepetitionBlockByIndex">
   <parameter name="refNode"/>
   <parameter name="index"/>
   <body><![CDATA[
    if (arguments.length < 2) {
      throw new SyntaxError("not enough arguments");
    }
    return this.addRepetitionBlock(refNode, index);
   ]]></body>
  </method>
  
  <method name="moveRepetitionBlock">
   <parameter name="distance"/>
   <body><![CDATA[
    if (arguments.length < 1) {
      throw new SyntaxError("not enough arguments");
    }
    return null;
   ]]></body>
  </method>
  
  <method name="removeRepetitionBlock">
   <parameter name="distance"/>
   <body><![CDATA[
    if (arguments.length < 1) {
      throw new SyntaxError("not enough arguments");
    }
    return null;
   ]]></body>
  </method>
 </implementation>
</binding>

<binding id="RepetitionTemplate" extends="#RepetitionElement">
 <implementation>
  <constructor><![CDATA[
   alert(99);
   if (this.parentNode && this.parentNode.nodeType == this.ELEMENT_NODE) {
     // maintain the mimimum number of blocks
     var i = 0;
     alert(this.repeatStart);
     while (i++ < this.repeatStart) {
       alert(i);
       this.addRepetitionBlock(null);
     }
     i = this.repetitionBlocks.length;
     while (i++ < this.repeatMin) {
       alert(i);
       this.addRepetitionBlock(null);
     }
     //this.repeat = "template"; // initialise buttons states
   }
  ]]></constructor>
  
  <!--
       
    This is an XBL frig.
    
    I don't want to add a public method to maintain the disabled state
    of the repetition buttons (add, remove etc).
    So we achieve this with a pointless setter.
    
  -->  
  <property name="repeat">
   <setter><![CDATA[
     if (val == "template") {
       var blocks = this.repetitionBlocks;
       for (var i = 0; i < blocks.length; i++) {
         var query = "./descendant::button[contains(@type='add' or @type='remove' or @type='move-up' or @type='move-down']";
         var query = "./descendant::button";
         var type = XPathResult.ORDERED_NODE_ITERATOR_TYPE;
         //var buttons = this.ownerDocument.evaluate(query, blocks[i], null, type, null);
         //while (button = buttons.iterateNext()) {
         var buttons = blocks[i].getElementsByTagName("button");
         for each (var button in buttons) {
           switch (button.type) {
             case "remove":
               button.disabled = blocks.length < this.repeatMin;
               break;
             case "move-up":
               button.disabled = (i == 0);
               break;
             case "move-down":
               button.disabled = (i == (blocks.length - 1));
               break;
             default:
               // my XPath was crap! ;-)
           }
         }         
       }
     } else {
       this.setAttribute("repeat", val);
     }
     return val;
   ]]></setter>
  </property>
  
  <!--
    
    This property should return a live HTMLCollection.
    
    This can't be created with JavaScript so we create
    a simple JavaScript object to contain the elements.
    
    THIS IS NOT A LIVE COLLECTION.
    
  -->
  <property name="repetitionBlocks">
   <getter>
    var blocks = {
      get length() {
        return length;
      },
      item: function item(index) {
        return this[index];
      }
    };
    var length = 0;
    var block = this.parentNode.firstChild;
    while (block = block.nextSibling) {
      if (block.repetitionTemplate == this) {
        blocks[length++] = block;
      }
    }
    return blocks;
   </getter>
  </property>
  
  <property name="repeatStart">
   <getter><![CDATA[
    var MAX_VALUE = Math.pow(2, 32) - 1;
    if (this.hasAttribute("repeat-start")) {
      var value = Number(this.getAttribute("repeat-start"));
      if (value && !isNaN(value) && value > 0 && value < MAX_VALUE) {
        return value;
      }
    }
    return 1;
   ]]></getter>
   <setter>
    if (val == 1) {
      this.removeAttribute("repeat-start");
    } else {
      this.setAttribute("repeat-start", val);
    }
    return val;
   </setter>
  </property>
  
  <property name="repeatMin">
   <getter><![CDATA[
    var MAX_VALUE = Math.pow(2, 32) - 1;
    if (this.hasAttribute("repeat-min")) {
      var value = Number(this.getAttribute("repeat-min"));
      if (value && !isNaN(value) && value > 0 && value < MAX_VALUE) {
        return value;
      }
    }
    return 0;
   ]]></getter>
   <setter>
    if (val == 0) {
      this.removeAttribute("repeat-min");
    } else {
      this.setAttribute("repeat-min", val);
    }
    return val;
   </setter>
  </property>
  
  <property name="repeatMax">
   <getter><![CDATA[
    var MAX_VALUE = Math.pow(2, 32) - 1;
    if (this.hasAttribute("repeat-max")) {
      var value = Number(this.getAttribute("repeat-max"));
      if (value && !isNaN(value) && value > 0 && value < MAX_VALUE) {
        return value;
      }
    }
    return Number.MAX_VALUE;
   ]]></getter>
   <setter>
    var MAX_VALUE = Math.pow(2, 32) - 1;
    if (val == MAX_VALUE) {
      this.removeAttribute("repeat-max");
    } else {
      this.setAttribute("repeat-max", val);
    }
    return val;
   </setter>
  </property>
  
  <method name="addRepetitionBlock">
   <parameter name="refNode"/>
   <body><![CDATA[
    if (arguments.length < 1) {
      throw new SyntaxError("not enough arguments");
    }
    if (this.parentNode && this.parentNode.nodeType == this.ELEMENT_NODE) {     
      // grab the preceding repetition blocks
      var blocks = [], block = this;
      while (block = block.previousSibling) {
        if (block.repetitionTemplate == this) {
          if (block.repetitionIndex >= this.repetitionIndex) {
            this.repetitionIndex = block.repetitionIndex + 1;
          }
          blocks.push(block);
        }
      }
     
      // quit if we have reached the maximum limit
      if (blocks.length > this.repeatMax) {
        return null;
      }
      
      // if this method was called by addRepetitionBlockByIndex()
      // then use its index
      if (arguments.callee.caller == this.addRepetitionBlockByIndex) {
        var index = arguments[1];
        if (index > this.repetitionIndex) {
          this.repetitionIndex = index;
        }
      }
     
      // clone this template and initialise the new block
      var block = this.cloneNode(true);
      if (arguments.callee.caller == this.addRepetitionBlockByIndex) {
        block.repetitionIndex = index;
      } else {
        block.repetitionIndex = this.repetitionIndex;
      }
      block.setAttribute("repeat", block.repetitionIndex);
      block.removeAttribute("repeat-start");
      block.removeAttribute("repeat-min");
      block.removeAttribute("repeat-max");
      
      // replace [indexed] expressions
      // we have to this for all attribute nodes
      var name = /[\[\u02d1\u00b7\]]/.test(this.id) ? "" : this.id;
      if (name) {
        var attribute;
        var safeName = name.replace(/([\/(){}|*+-.,^$?\\])/g, "\\$1");
        var pattern = new RegExp("[\\[\\u02d1]" + safeName + "[\\u00b7\\]]", "g");
        var query = "./descendant::*/attribute::*[contains(translate(.,'\u02d1','['), '[')]";
        var type = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
        var attributes = this.ownerDocument.evaluate(query, block, null, type, null);
        while (attribute = attributes.iterateNext()) {
          attribute.value = attribute.value.replace(pattern, block.repetitionIndex);
        }
        block.setAttribute("repeat-template", name);
        block.removeAttribute("id");
      }
      // insert the node
      if (refNode == null) {
        refNode = this;
        while (refNode.previousSibling && refNode.previousSibling.repetitionType != this.REPETITION_BLOCK) {
          refNode = refNode.previousSibling
        }
      } else {
        refNode = refNode.nextSibling;
      }
      refNode.parentNode.insertBefore(block, refNode);
      
      // maintain the index
      this.repetitionIndex++;
     
      // fire the "added" event
      var event = this.ownerDocument.createEvent("Events");
      event.initEvent("added", false, false);
      event.element = block;
      this.dispatchEvent(event);
      
      // return the newly created block
      return block;
    }
    return null;
   ]]></body>
  </method>
 </implementation>
</binding>

<binding id="RepetitionBlock" extends="#RepetitionElement">
 <implementation> 
  <property name="repetitionTemplate">
   <getter><![CDATA[
    if (this.repetitionType == this.REPETITION_BLOCK) {
      if (this.hasAttribute("repeat-template")) {
        var templateId = this.getAttribute("repeat-template");
        var template = this.ownerDocument.getElementById(templateId);
      } else {
        template = this;
        while ((template = template.nextSibling) && template.repetitionType != this.REPETITION_TEMPLATE) {
          continue;
        }
      }
    }
    if (template && template.repetitionType == this.REPETITION_TEMPLATE) {
       return template;
    }
    return null;
   ]]></getter>
  </property>
  
  <method name="removeRepetitionBlock">
   <body><![CDATA[
    if (this.repetitionType == this.REPETITION_BLOCK) {   
      var template = this.repetitionTemplate;
      
      this.parentNode.removeChild(this);
     
      if (template) { // not an orphan
        // fire the "removed" event on the template
        var event = this.ownerDocument.createEvent("Events");
        event.initEvent("removed", false, false);
        event.element = this;
        template.dispatchEvent(event);
        
        // maintain the mimimum number of blocks
        var length = template.repetitionBlocks.length;
        while (length++ < template.repeatMin) {
          template.addRepetitionBlock();
        }
      }
    }
   ]]></body>
  </method>
  
  <method name="moveRepetitionBlock">
   <parameter name="distance"/>
   <body><![CDATA[
    if (arguments.length < 1) {
      throw new SyntaxError("not enough arguments");
    }
    if (this.repetitionType == this.REPETITION_BLOCK) {    
      if (!distance) return;
     
      var target = this;
      var template = this.repetitionTemplate;
     
      if (distance < 0) {
        while (distance < 0 && target.previousSibling && target.previousSibling.repetitionType != this.REPETITION_TEMPLATE) {
          target = target.previousSibling;
          if (target.repetitionType == this.REPETITION_BLOCK) {
            distance++;
          }
        }
      } else {
        while (distance > 0 && target.nextSibling && target.nextSibling.repetitionType != this.REPETITION_TEMPLATE) {
          target = target.nextSibling;
          if (target.repetitionType == this.REPETITION_BLOCK) {
            distance--;
          }
        }
        target = target.nextSibling;
      }
     
      // move the block
      this.parentNode.insertBefore(this, target);
     
      if (template) { // not an orphan
        // fire the "moved" event on the template
        var event = this.ownerDocument.createEvent("Events");
        event.initEvent("moved", false, false);
        event.element = this;
        template.dispatchEvent(event);
      }
    }
   ]]></body>
  </method>
 </implementation>
</binding>

<binding id="RepetitionButtonElement" extends="#RepetitionElement">
 <handlers>
  <handler event="click"><![CDATA[
   event.preventDefault();
  ]]></handler>
 </handlers>
</binding>

<binding id="RepetitionButtonAdd" extends="#RepetitionButtonElement">
 <handlers>
  <handler event="click"><![CDATA[
   if (this.hasAttribute("template")) {
     var templateId = this.getAttribute("template");
     var template = this.ownerDocument.getElementById(templateId);
     if (template && template.repetitionType == this.REPETITION_TEMPLATE) {
       template.addRepetitionBlock(null);
       template.repeat = "template"; // refresh button states
     }
   } else {
     var block = this;
     while (block && (block.repetitionType != this.REPETITION_BLOCK || !block.repetitionTemplate)) {
       block = block.parentNode;
     }
     if (block) {
       block.repetitionTemplate.addRepetitionBlock(block);
       block.repetitionTemplate.repeat = "template"; // refresh button states
     }
   }
  ]]></handler>
 </handlers>
</binding>

<binding id="RepetitionButtonRemove" extends="#RepetitionButtonElement">
 <handlers>
  <handler event="click"><![CDATA[
   var block = this;
   while (block && (block.repetitionType != this.REPETITION_BLOCK || !block.repetitionTemplate)) {
     block = block.parentNode;
   }
   if (block) {
     block.removeRepetitionBlock();
     block.repetitionTemplate.repeat = "template"; // refresh button states
   }
  ]]></handler>
 </handlers>
</binding>

<binding id="RepetitionButtonMoveUp" extends="#RepetitionButtonElement">
 <handlers>
  <handler event="click"><![CDATA[
   var block = this;
   while (block && (block.repetitionType != this.REPETITION_BLOCK || !block.repetitionTemplate)) {
     block = block.parentNode;
   }
   if (block) {
     block.moveRepetitionBlock(-1);
     block.repetitionTemplate.repeat = "template"; // refresh button states
   }
  ]]></handler>
 </handlers>
</binding>

<binding id="RepetitionButtonMoveDown" extends="#RepetitionButtonElement">
 <handlers>
  <handler event="click"><![CDATA[
   var block = this;
   while (block && (block.repetitionType != this.REPETITION_BLOCK || !block.repetitionTemplate)) {
     block = block.parentNode;
   }
   if (block) {
     block.moveRepetitionBlock(+1);     
     block.repetitionTemplate.repeat = "template"; // refresh button states
   }
  ]]></handler>
 </handlers>
</binding>

</bindings>
